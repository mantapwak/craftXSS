<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XSS Payload Encoder/Decoder | Security Research Tool</title>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; object-src 'none'; frame-src 'none';">
    <style>
        /* --- General Styling & Variables --- */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-tertiary: #334155;
            --text-primary: #f1f5f9;
            --text-secondary: #cbd5e1;
            --text-muted: #64748b;
            --accent: #3b82f6;
            --accent-hover: #2563eb;
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
            --border: #475569;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1);
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 1rem;
        }

        /* --- Header & Disclaimer --- */
        .header {
            text-align: center;
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--border);
        }

        .header h1 {
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            font-weight: 700;
            margin-bottom: 0.5rem;
            background: linear-gradient(135deg, var(--accent), var(--success));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            color: var(--text-secondary);
            font-size: clamp(0.9rem, 2vw, 1.1rem);
        }

        .disclaimer {
            background: var(--bg-secondary);
            border: 1px solid var(--warning);
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 2rem;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        /* --- Main Layout --- */
        .main-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .panel {
            background: var(--bg-secondary);
            border-radius: 0.75rem;
            padding: 1rem;
            box-shadow: var(--shadow);
            border: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            min-width: 0; /* BUG FIX: Prevents grid item from expanding beyond its boundary */
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .panel-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .char-count {
            font-size: 0.875rem;
            color: var(--text-muted);
        }

        /* --- Input/Output Areas --- */
        textarea, #output-container {
            width: 100%;
            min-height: 200px;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            padding: 1rem;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            font-size: 0.875rem;
            resize: vertical;
            transition: border-color 0.2s;
            flex-grow: 1;
        }
        
        #output-container {
            overflow-y: auto;
        }

        .output-group {
            margin-bottom: 1rem;
        }
        .output-group:last-child {
            margin-bottom: 0;
        }
        .output-group h5 {
            color: var(--accent);
            font-weight: 600;
            margin-bottom: 0.5rem;
        }
        .output-group pre {
            background: var(--bg-tertiary);
            padding: 0.75rem;
            border-radius: 0.375rem;
            white-space: pre-wrap;
            overflow-wrap: break-word;
            overflow-x: auto; /* Add horizontal scroll for long unbreakable strings */
            color: var(--text-secondary);
        }

        textarea:focus {
            outline: none;
            border-color: var(--accent);
        }

        /* --- Controls & Buttons --- */
        .controls {
            margin-top: 1rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .control-row {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        button {
            padding: 0.75rem 1rem;
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 0.875rem;
            transition: all 0.2s;
            flex: 1;
            min-width: 0;
            cursor: pointer;
            font-weight: 500;
        }

        .btn-primary { background: var(--accent); border-color: var(--accent); color: white; }
        .btn-primary:hover { background: var(--accent-hover); border-color: var(--accent-hover); }
        .btn-secondary { background: var(--bg-tertiary); border-color: var(--border); }
        .btn-secondary:hover { background: var(--border); }
        .btn-success { background: var(--success); border-color: var(--success); color: white; }
        .btn-success:hover { background: #059669; border-color: #059669; }

        /* --- Advanced Options Grid --- */
        .options-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1rem;
            margin-top: 1rem;
        }

        .option-group {
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            padding: 1rem;
        }

        .option-group h4 {
            font-size: 0.875rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .checkbox-item input[type="checkbox"] {
            width: 1rem;
            height: 1rem;
            accent-color: var(--accent);
            flex-shrink: 0;
        }

        .checkbox-item label {
            font-size: 0.875rem;
            color: var(--text-secondary);
            cursor: pointer;
            line-height: 1.4;
        }

        /* --- Encoding Chain & Toast --- */
        .encoding-chain {
            background: var(--bg-secondary);
            border-radius: 0.75rem;
            padding: 1rem;
            margin-top: 2rem;
            border: 1px solid var(--border);
        }

        .chain-header {
            font-size: 1.125rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--text-primary);
        }

        .chain-steps {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .chain-step {
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 0.375rem;
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .chain-arrow {
            color: var(--text-muted);
            font-size: 0.875rem;
            flex-shrink: 0;
        }

        .toast {
            position: fixed;
            top: 1rem;
            right: 1rem;
            left: 1rem;
            background: var(--success);
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 0.5rem;
            box-shadow: var(--shadow-lg);
            z-index: 1000;
            transform: translateY(-100%);
            transition: transform 0.3s ease;
            word-wrap: break-word;
        }
        
        .toast.show {
            transform: translateY(0);
        }
        .toast.error { background: var(--error); }
        .toast.warning { background: var(--warning); }

        /* --- Responsive Design --- */
        
        /* Tablet & Small Desktop */
        @media (min-width: 768px) {
            .panel { padding: 1.5rem; }
            textarea, #output-container { min-height: 300px; }
            .control-row { gap: 1rem; }
            button { flex: 1; }
        }

        /* Desktop */
        @media (min-width: 1024px) {
            .main-grid {
                grid-template-columns: 1fr 1fr;
                gap: 2rem;
            }
            .options-grid {
                grid-template-columns: repeat(4, 1fr);
            }
        }
        
        /* Small Tablet */
        @media (min-width: 640px) {
            .options-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            .toast {
                top: 2rem;
                right: 2rem;
                left: auto;
                max-width: 400px;
                transform: translateX(100%);
            }
            .toast.show {
                transform: translateX(0);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>XSS Payload Encoder/Decoder</h1>
            <p>Professional Security Research Tool for Bug Bounty Hunters</p>
        </header>

        <div class="disclaimer">
         <!-- Encoding Chain -->
        <!-- <div class="encoding-chain"> -->
            <div class="chain-header">Encoding Chain</div>
            <div class="chain-steps" id="encodingChain">
                <span class="chain-step">No operations performed</span>
            </div>
        <!-- </div>     -->
        </div>

        <div class="main-grid">
            <!-- Input Panel -->
            <div class="panel">
                <div class="panel-header">
                    <h3 class="panel-title">Input</h3>
                    <span class="char-count" id="inputCount">0 chars</span>
                </div>
                <textarea id="inputText" placeholder="Enter your payload here..."></textarea>
                
                <div class="controls">
                    <div class="control-row">
                        <button type="button" class="btn-primary" id="encodeBtn">Encode</button>
                        <button type="button" class="btn-success" id="decodeBtn">Auto-Decode</button>
                        <button type="button" class="btn-secondary" id="clearBtn">Clear All</button>
                    </div>
                </div>
            </div>

            <!-- Output Panel -->
            <div class="panel">
                <div class="panel-header">
                    <h3 class="panel-title">Output</h3>
                     <span class="char-count" id="outputCount">0 chars</span>
                </div>
                <div id="output-container">
                    <span style="color: var(--text-muted);">Processed output will appear here...</span>
                </div>
                <div class="controls">
                    <div class="control-row">
                        <button type="button" class="btn-secondary" id="copyAllBtn">Copy All Results</button>
                        <button type="button" class="btn-secondary" id="swapBtn">Swap Input/Output</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Advanced Options -->
        <div class="options-grid">
            <div class="option-group">
                <h4>Case Variations</h4>
                <div class="checkbox-group">
                    <div class="checkbox-item"><input type="checkbox" id="caseCapitalize"><label for="caseCapitalize">Capitalize First Letter</label></div>
                    <div class="checkbox-item"><input type="checkbox" id="caseUpper"><label for="caseUpper">UPPERCASE</label></div>
                    <div class="checkbox-item"><input type="checkbox" id="caseMixed"><label for="caseMixed">MiXeD cAsE</label></div>
                    <div class="checkbox-item"><input type="checkbox" id="caseRandom"><label for="caseRandom">Random Case</label></div>
                </div>
            </div>

            <div class="option-group">
                <h4>Whitespace & Karakter Khusus</h4>
                <div class="checkbox-group">
                    <div class="checkbox-item"><input type="checkbox" id="wsSpace"><label for="wsSpace">Space to &amp;nbsp;</label></div>
                    <div class="checkbox-item"><input type="checkbox" id="wsTab"><label for="wsTab">Space to Tab</label></div>
                    <div class="checkbox-item"><input type="checkbox" id="wsNewline"><label for="wsNewline">Space to Newline</label></div>
                    <div class="checkbox-item"><input type="checkbox" id="wsCarriageReturn"><label for="wsCarriageReturn">Space to Carriage Return</label></div>
                    <div class="checkbox-item"><input type="checkbox" id="wsFormFeed"><label for="wsFormFeed">Space to Form Feed</label></div>
                </div>
            </div>

            <div class="option-group">
                <h4>Bypass Techniques</h4>
                <div class="checkbox-group">
                    <div class="checkbox-item"><input type="checkbox" id="splitKeyword"><label for="splitKeyword">Split Keywords (Trojan)</label></div>
                    <div class="checkbox-item"><input type="checkbox" id="attrInjection"><label for="attrInjection">Non-required Attributes</label></div>
                    <div class="checkbox-item"><input type="checkbox" id="commentInsert"><label for="commentInsert">Comment Insertion</label></div>
                    <div class="checkbox-item"><input type="checkbox" id="zeroWidth"><label for="zeroWidth">Zero-width Characters</label></div>
                    <div class="checkbox-item"><input type="checkbox" id="stringConcat"><label for="stringConcat">String Concat</label></div>
                    <div class="checkbox-item"><input type="checkbox" id="fromCharCode"><label for="fromCharCode">FromCharCode Obfuscation</label></div>
                </div>
            </div>

            <div class="option-group">
                <h4>Advanced Options</h4>
                <div class="checkbox-group">
                    <div class="checkbox-item"><input type="checkbox" id="homograph"><label for="homograph">Homograph Substitution</label></div>
                    <div class="checkbox-item"><input type="checkbox" id="rtlOverride"><label for="rtlOverride">RTL Override</label></div>
                    <div class="checkbox-item"><input type="checkbox" id="tripleEncode"><label for="tripleEncode">Triple Encoding</label></div>
                    <div class="checkbox-item"><input type="checkbox" id="preserveLength"><label for="preserveLength">Preserve Length</label></div>
                </div>
            </div>
        </div>

       
    </div>

    <!-- Toast Notification -->
    <div class="toast" id="toast"></div>

    <script>
        class XSSPayloadTool {
            constructor() {
                this.initializeElements();
                this.bindEvents();
                this.encodingHistory = [];
            }

            initializeElements() {
                this.inputText = document.getElementById('inputText');
                this.outputContainer = document.getElementById('output-container');
                this.encodeBtn = document.getElementById('encodeBtn');
                this.decodeBtn = document.getElementById('decodeBtn');
                this.clearBtn = document.getElementById('clearBtn');
                this.copyAllBtn = document.getElementById('copyAllBtn');
                this.swapBtn = document.getElementById('swapBtn');
                this.inputCount = document.getElementById('inputCount');
                this.outputCount = document.getElementById('outputCount');
                this.encodingChain = document.getElementById('encodingChain');
                this.toast = document.getElementById('toast');
            }

            bindEvents() {
                this.inputText.addEventListener('input', () => this.updateCharCount());
                this.encodeBtn.addEventListener('click', () => this.runEncoder());
                this.decodeBtn.addEventListener('click', () => this.runDecoder());
                this.clearBtn.addEventListener('click', () => this.clearAll());
                this.copyAllBtn.addEventListener('click', () => this.copyAllResults());
                this.swapBtn.addEventListener('click', () => this.swapInputOutput());
            }

            // Input sanitization
            sanitizeInput(input) {
                if (typeof input !== 'string') return '';
                if (input.length > 50000) {
                    input = input.substring(0, 50000);
                    this.showToast('Input truncated to 50,000 characters for safety', 'warning');
                }
                return input;
            }

            updateCharCount() {
                const inputLength = this.inputText.value.length;
                this.inputCount.textContent = `${inputLength} chars`;
                const outputText = this.outputContainer.innerText;
                this.outputCount.textContent = `${outputText.length} chars`;
            }
            
            // --- ENCODING LOGIC ---

            runEncoder() {
                let input = this.sanitizeInput(this.inputText.value);
                if (!input) {
                    this.showToast('Please enter some input text', 'warning');
                    return;
                }

                // Apply advanced options first
                let modifiedInput = this.applyAdvancedOptions(input);

                const encodingMethods = {
                    'URL Encoding': this.encodeURL,
                    'HTML Entity': this.encodeHTMLEntity,
                    'Double URL Encoding': this.encodeDoubleURL,
                    'Base64 Standard': this.encodeBase64,
                    'Base64 URL-Safe': this.encodeBase64URL,
                    'ASCII Octal': this.encodeASCIIOctal,
                    'ASCII Decimal': this.encodeASCIIDecimal,
                    'ASCII Hexadecimal': this.encodeASCIIHex,
                    'Unicode UTF-16': this.encodeUnicodeUTF16,
                };
                
                if (document.getElementById('tripleEncode').checked) {
                     encodingMethods['Triple URL Encoding'] = (text) => this.encodeURL(this.encodeURL(this.encodeURL(text)));
                }

                let results = {};

                // Add the new "variations only" result at the top
                const shortInput = input.length > 20 ? input.substring(0, 20) + '...' : input;
                results[`'${shortInput}' + Variations`] = modifiedInput;

                for (const [name, func] of Object.entries(encodingMethods)) {
                    try {
                        // Each encoding method is applied to the already modified input
                        results[name] = func.call(this, modifiedInput);
                    } catch (e) {
                        results[name] = `Error: ${e.message}`;
                    }
                }
                
                this.renderEncodeResults(results);
                this.updateEncodingChain('ENCODE', 'ALL METHODS + VARIATIONS');
                this.showToast('Encoding complete', 'success');
            }
            
            renderEncodeResults(results) {
                this.outputContainer.innerHTML = '';
                for (const [name, value] of Object.entries(results)) {
                    const group = document.createElement('div');
                    group.className = 'output-group';

                    const title = document.createElement('h5');
                    title.textContent = name;
                    
                    const pre = document.createElement('pre');
                    pre.textContent = value;

                    group.appendChild(title);
                    group.appendChild(pre);
                    this.outputContainer.appendChild(group);
                }
                this.updateCharCount();
            }

            // --- DECODING LOGIC ---

            runDecoder() {
                let input = this.sanitizeInput(this.inputText.value);
                if (!input) {
                    this.showToast('Please enter some input text', 'warning');
                    return;
                }
                
                // First, normalize all possible whitespace variations to a standard space
                input = input.replace(/[\t\n\r\f\u00A0]/g, ' ');

                const detectionOrder = [
                    { name: 'Base64 URL-Safe', func: this.decodeBase64URL, regex: /^[A-Za-z0-9\-_]+$/ },
                    { name: 'Base64 Standard', func: this.decodeBase64, regex: /^[A-Za-z0-9+/=]+$/ },
                    { name: 'Double URL', func: this.decodeDoubleURL, regex: /%25/ }, // Contains %25
                    { name: 'URL', func: this.decodeURL, regex: /%/ },
                    { name: 'HTML Entity', func: this.decodeHTMLEntity, regex: /&(#?[\w\d]+);/ },
                    { name: 'ASCII Hexadecimal', func: this.decodeASCIIHex, regex: /(\\x[0-9a-fA-F]{2})+/ },
                    { name: 'ASCII Octal', func: this.decodeASCIIOctal, regex: /(\\[0-7]{1,3})+/ },
                    { name: 'ASCII Decimal', func: this.decodeASCIIDecimal, regex: /(&#\d+;)+/ },
                    { name: 'Unicode UTF-16', func: this.decodeUnicodeUTF16, regex: /(\\u\{[0-9a-fA-F]+\})+/ },
                ];

                for (const decoder of detectionOrder) {
                    if (decoder.regex && !decoder.regex.test(input)) {
                        continue;
                    }
                    try {
                        const result = decoder.func.call(this, input);
                        if (result !== input && result.length > 0) {
                            this.renderDecodeResult(decoder.name, result);
                            this.updateEncodingChain('DECODE', `AUTO-DETECTED: ${decoder.name}`);
                            this.showToast(`Successfully decoded as ${decoder.name}`, 'success');
                            return;
                        }
                    } catch (e) {
                        // Ignore errors
                    }
                }
                
                this.renderDecodeResult('Detection Failed', 'Could not automatically determine the encoding type.');
                this.showToast('Auto-detection failed', 'error');
            }

            renderDecodeResult(method, result) {
                this.outputContainer.innerHTML = '';
                const group = document.createElement('div');
                group.className = 'output-group';

                const title = document.createElement('h5');
                title.textContent = `Detected Method: ${method}`;
                
                const pre = document.createElement('pre');
                pre.textContent = result;

                group.appendChild(title);
                group.appendChild(pre);
                this.outputContainer.appendChild(group);
                this.updateCharCount();
            }


            // --- UTILITY & HELPER FUNCTIONS ---

            updateEncodingChain(operation, method) {
                const step = `${operation}: ${method.toUpperCase()}`;
                this.encodingHistory.push(step);
                if (this.encodingHistory.length > 5) { this.encodingHistory.shift(); }
                this.renderEncodingChain();
            }

            renderEncodingChain() {
                this.encodingChain.innerHTML = '';
                if (this.encodingHistory.length === 0) {
                    this.encodingChain.innerHTML = '<span class="chain-step">No operations performed</span>';
                    return;
                }
                this.encodingHistory.forEach((step, index) => {
                    if (index > 0) {
                        const arrow = document.createElement('span');
                        arrow.className = 'chain-arrow';
                        arrow.textContent = '→';
                        this.encodingChain.appendChild(arrow);
                    }
                    const stepElement = document.createElement('span');
                    stepElement.className = 'chain-step';
                    stepElement.textContent = step;
                    this.encodingChain.appendChild(stepElement);
                });
            }

            clearAll() {
                this.inputText.value = '';
                this.outputContainer.innerHTML = '<span style="color: var(--text-muted);">Processed output will appear here...</span>';
                this.encodingHistory = [];
                this.renderEncodingChain();
                this.updateCharCount();
                document.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
                this.showToast('All data cleared', 'success');
            }

            async copyAllResults() {
                const groups = this.outputContainer.querySelectorAll('.output-group');
                if (groups.length === 0) {
                    this.showToast('No output to copy', 'warning');
                    return;
                }
                let allText = '';
                groups.forEach(group => {
                    const title = group.querySelector('h5').innerText.trim();
                    const value = group.querySelector('pre').innerText;
                    allText += `${title}:\n${value}\n\n`;
                });
                try {
                    await navigator.clipboard.writeText(allText.trim());
                    this.showToast('All results copied', 'success');
                } catch (error) {
                    this.showToast('Failed to copy', 'error');
                }
            }

            swapInputOutput() {
                const inputValue = this.inputText.value;
                const outputValue = this.outputContainer.innerText;
                this.inputText.value = outputValue;
                this.outputContainer.innerHTML = `<div class="output-group"><pre>${inputValue}</pre></div>`;
                this.updateCharCount();
                this.showToast('Input and output swapped', 'success');
            }

            showToast(message, type = 'success') {
                this.toast.textContent = message;
                this.toast.className = `toast ${type}`;
                this.toast.classList.add('show');
                setTimeout(() => this.toast.classList.remove('show'), 3000);
            }

            // --- Encoding/Decoding Methods ---
            encodeURL(text) { return encodeURIComponent(text); }
            decodeURL(text) { try { return decodeURIComponent(text.replace(/\+/g, ' ')); } catch (e) { throw new Error('Invalid URL'); } }
            encodeHTMLEntity(text) { 
                return text.replace(/[&<>"'\t\n\r\f ]/g, (char) => ({
                    '&':'&amp;', '<':'&lt;', '>':'&gt;', '"':'&quot;', "'":'&#x27;', ' ':'&#32;', 
                    '\t':'&#9;', '\n':'&#10;', '\r':'&#13;', '\f':'&#12;'
                })[char] || char);
            }
            decodeHTMLEntity(text) { const el = document.createElement('textarea'); el.innerHTML = text; return el.value; }
            encodeDoubleURL(text) { return this.encodeURL(this.encodeURL(text)); }
            decodeDoubleURL(text) { return this.decodeURL(this.decodeURL(text)); }
            encodeBase64(text) { try { return btoa(unescape(encodeURIComponent(text))); } catch (e) { throw new Error('Base64 failed'); } }
            decodeBase64(text) { try { return decodeURIComponent(escape(atob(text.replace(/[^A-Za-z0-9+/=]/g, '')))); } catch (e) { throw new Error('Invalid Base64'); } }
            encodeBase64URL(text) { return this.encodeBase64(text).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, ''); }
            decodeBase64URL(text) { let padded = text.replace(/-/g, '+').replace(/_/g, '/'); while (padded.length % 4) { padded += '='; } return this.decodeBase64(padded); }
            encodeASCIIOctal(text) { return text.split('').map(char => '\\' + char.charCodeAt(0).toString(8)).join(''); }
            decodeASCIIOctal(text) { return text.replace(/\\([0-7]{1,3})/g, (_, octal) => String.fromCharCode(parseInt(octal, 8))); }
            encodeASCIIDecimal(text) { return text.split('').map(char => `&#${char.charCodeAt(0)};`).join(''); }
            decodeASCIIDecimal(text) { return text.replace(/&#(\d+);/g, (_, decimal) => String.fromCharCode(parseInt(decimal, 10))); }
            encodeASCIIHex(text) { return text.split('').map(char => '\\x' + char.charCodeAt(0).toString(16).padStart(2, '0')).join(''); }
            decodeASCIIHex(text) { return text.replace(/\\x([0-9a-fA-F]{2})/g, (_, hex) => String.fromCharCode(parseInt(hex, 16))); }
            encodeUnicodeUTF16(text) { return text.split('').map(c => '\\u{' + c.charCodeAt(0).toString(16) + '}').join(''); }
            decodeUnicodeUTF16(text) { return text.replace(/\\u\{([0-9a-fA-F]+)\}/g, (_, unicode) => String.fromCharCode(parseInt(unicode, 16))); }
            
            applyAdvancedOptions(text) {
                let result = text;
                // These options are applied sequentially. Order can matter.
                if (document.getElementById('caseCapitalize').checked) { result = result.charAt(0).toUpperCase() + result.slice(1); }
                if (document.getElementById('caseUpper').checked) { result = result.toUpperCase(); }
                if (document.getElementById('caseMixed').checked) { result = result.split('').map((c, i) => i % 2 === 0 ? c.toLowerCase() : c.toUpperCase()).join(''); }
                if (document.getElementById('caseRandom').checked) { result = result.split('').map(c => Math.random() > 0.5 ? c.toUpperCase() : c.toLowerCase()).join(''); }
                
                // New Whitespace logic: only one can be applied. Priority order.
                if (document.getElementById('wsTab').checked) { result = result.replace(/\s/g, '\t'); }
                else if (document.getElementById('wsNewline').checked) { result = result.replace(/\s/g, '\n'); }
                else if (document.getElementById('wsCarriageReturn').checked) { result = result.replace(/\s/g, '\r'); }
                else if (document.getElementById('wsFormFeed').checked) { result = result.replace(/\s/g, '\f'); }
                else if (document.getElementById('wsSpace').checked) { result = result.replace(/ /g, '\u00A0'); } // Replace standard space with non-breaking space
                
                if (document.getElementById('splitKeyword').checked) { result = result.replace(/script/gi, 'scr<!---->ipt').replace(/alert/gi, 'al<!---->ert'); }
                if (document.getElementById('attrInjection').checked) { result = result.replace(/<script/gi, '<sc\r\ni\r\npt'); }
                if (document.getElementById('commentInsert').checked) { result = result.replace(/</g, '<!-- --> < <!-- -->'); }
                if (document.getElementById('zeroWidth').checked) { result = result.split('').join('\u200B'); }
                if (document.getElementById('homograph').checked) { const h={'a':'а','e':'е','o':'о','p':'р','c':'с','x':'х','y':'у'}; result = result.replace(/[aeopcxy]/gi, c => h[c.toLowerCase()] || c); }
                if (document.getElementById('rtlOverride').checked) { result = '\u202E' + result + '\u202C'; }
                
                // New bypass techniques
                if (document.getElementById('stringConcat').checked) {
                    const keywords = ['script', 'alert', 'document', 'cookie', 'window', 'location', 'eval'];
                    keywords.forEach(kw => {
                        const regex = new RegExp(kw, 'gi');
                        const concat = "'" + kw.split('').join("'+'") + "'";
                        result = result.replace(regex, concat);
                    });
                }
                if (document.getElementById('fromCharCode').checked) {
                    const charCodes = result.split('').map(c => c.charCodeAt(0)).join(',');
                    result = `String.fromCharCode(${charCodes})`;
                }
                return result;
            }
        }

        document.addEventListener('DOMContentLoaded', () => new XSSPayloadTool());
        window.addEventListener('error', (event) => { console.error('Application error:', event.error); event.preventDefault(); });
        window.eval = () => { throw new Error('eval() is disabled for security'); };
    </script>
</body>
</html>
